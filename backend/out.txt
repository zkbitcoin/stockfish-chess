============================= test session starts ==============================
platform darwin -- Python 3.8.19, pytest-6.2.2, py-1.11.0, pluggy-0.13.1
rootdir: /Users/amilkowski/git/stockfish-chess/backend
plugins: anyio-4.5.2
collected 16 items

app/api/api_v1/routers/tests/test_auth.py EEEEE                          [ 31%]
app/api/api_v1/routers/tests/test_game.py E                              [ 37%]
app/api/api_v1/routers/tests/test_users.py EEEEEEEEEE                    [100%]

==================================== ERRORS ====================================
_________________________ ERROR at setup of test_login _________________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
________________________ ERROR at setup of test_signup _________________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
_______________________ ERROR at setup of test_resignup ________________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
____________________ ERROR at setup of test_wrong_password _____________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
______________________ ERROR at setup of test_wrong_login ______________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
_________________________ ERROR at setup of test_game __________________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
_______________________ ERROR at setup of test_get_users _______________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
______________________ ERROR at setup of test_delete_user ______________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
_________________ ERROR at setup of test_delete_user_not_found _________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
_______________________ ERROR at setup of test_edit_user _______________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ ERROR at setup of test_edit_user_not_found __________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
_______________________ ERROR at setup of test_get_user ________________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
____________________ ERROR at setup of test_user_not_found _____________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
_________________ ERROR at setup of test_authenticated_user_me _________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
________________ ERROR at setup of test_unauthenticated_routes _________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ ERROR at setup of test_unauthorized_routes __________________

self = Engine(postgresql://postgres:***@postgres:5432)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3d00>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x106fc2d60>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
            connection = pool._invoke_creator(self)
            pool.logger.debug("Created new connection %r", connection)
            self.connection = connection
        except Exception as e:
            with util.safe_reraise():
>               pool.logger.debug("Error on connect(): %s", e)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x106fd3e50>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.raise_(
                    exc_value, with_traceback=exc_tb,
                )

.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def raise_(
        exception, with_traceback=None, replace_context=None, from_=False
    ):
        r"""implement "raise" with cause support.
    
        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.
    
        """
        if with_traceback is not None:
            exception = exception.with_traceback(with_traceback)
    
        if from_ is not False:
            exception.__cause__ = from_
        elif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
            exception.__cause__ = replace_context
    
        try:
>           raise exception

.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x106fd3f10>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x106fc2910>
cargs = ()
cparams = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}

    def connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
>       return self.dbapi.connect(*cargs, **cparams)

.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not translate host name "postgres" to address: nodename nor servname provided, or not known

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session", autouse=True)
    def create_test_db():
        """
        Create a test database and use it for the whole test session.
        """
    
        test_db_url = get_test_db_url()
    
        # Create the test database
>       assert not database_exists(
            test_db_url
        ), "Test database already exists. Aborting tests."

conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:466: in database_exists
    return bool(get_scalar_result(engine, text))
.venv/lib/python3.8/site-packages/sqlalchemy_utils/functions/database.py:445: in get_scalar_result
    result_proxy = engine.execute(sql)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2236: in execute
    connection = self._contextual_connect(close_with_result=True)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2304: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2341: in _wrap_pool_connect
    Connection._handle_dbapi_exception_noconnection(
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1583: in _handle_dbapi_exception_noconnection
    util.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2338: in _wrap_pool_connect
    return fn()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:364: in connect
    return _ConnectionFairy._checkout(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:778: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:495: in checkout
    rec = pool._do_get()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:140: in _do_get
    self._dec_overflow()
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:137: in _do_get
    return self._create_connection()
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:309: in _create_connection
    return _ConnectionRecord(self)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:440: in __init__
    self.__connect(first_connect_check=True)
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect
    pool.logger.debug("Error on connect(): %s", e)
.venv/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.raise_(
.venv/lib/python3.8/site-packages/sqlalchemy/util/compat.py:182: in raise_
    raise exception
.venv/lib/python3.8/site-packages/sqlalchemy/pool/base.py:656: in __connect
    connection = pool._invoke_creator(self)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
.venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py:493: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=postgres user=postgres password=password port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'host': 'postgres', 'password': 'password', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not translate host name "postgres" to address: nodename nor servname provided, or not known
E       
E       (Background on this error at: http://sqlalche.me/e/13/e3q8)

.venv/lib/python3.8/site-packages/psycopg2/__init__.py:122: OperationalError
=========================== short test summary info ============================
ERROR app/api/api_v1/routers/tests/test_auth.py::test_login - sqlalchemy.exc....
ERROR app/api/api_v1/routers/tests/test_auth.py::test_signup - sqlalchemy.exc...
ERROR app/api/api_v1/routers/tests/test_auth.py::test_resignup - sqlalchemy.e...
ERROR app/api/api_v1/routers/tests/test_auth.py::test_wrong_password - sqlalc...
ERROR app/api/api_v1/routers/tests/test_auth.py::test_wrong_login - sqlalchem...
ERROR app/api/api_v1/routers/tests/test_game.py::test_game - sqlalchemy.exc.O...
ERROR app/api/api_v1/routers/tests/test_users.py::test_get_users - sqlalchemy...
ERROR app/api/api_v1/routers/tests/test_users.py::test_delete_user - sqlalche...
ERROR app/api/api_v1/routers/tests/test_users.py::test_delete_user_not_found
ERROR app/api/api_v1/routers/tests/test_users.py::test_edit_user - sqlalchemy...
ERROR app/api/api_v1/routers/tests/test_users.py::test_edit_user_not_found - ...
ERROR app/api/api_v1/routers/tests/test_users.py::test_get_user - sqlalchemy....
ERROR app/api/api_v1/routers/tests/test_users.py::test_user_not_found - sqlal...
ERROR app/api/api_v1/routers/tests/test_users.py::test_authenticated_user_me
ERROR app/api/api_v1/routers/tests/test_users.py::test_unauthenticated_routes
ERROR app/api/api_v1/routers/tests/test_users.py::test_unauthorized_routes - ...
============================== 16 errors in 1.84s ==============================
